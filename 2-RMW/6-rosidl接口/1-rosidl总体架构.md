# 层次化架构

![](https://tcs.teambition.net/storage/312f5736d06d4d18ddc3d624a28f21a9fbb9?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3MTc5ODk2NCwiaWF0IjoxNjcxMTk0MTY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmY1NzM2ZDA2ZDRkMThkZGMzZDYyNGEyOGYyMWE5ZmJiOSJ9.uNHOtI-xtTTQ_hWIe3CWauUfa6SOfTvHvoeBOC6xe9c&download=image.png "")

Transport layer 和message clustering为运输层，运输层以下由OS的默认网络栈完成，运输层以上有表示层，表示层由serializatio完成，有不同的串行化方式，protobuf是ecal的默认方式，最上面为应用层，整个rcl及以上就在应用层。

应用层还可以再分，分为rcl, rclcpp, ros2 node app等。

# 共同的概念RCL

这些概念使得ROS为ROS，但是可以使用不同的语言来实现，如rclcpp或者rclpy

与编程语言无关的，则为RCL

为了使得rclcpp开发更为方便，RCL暴露了C接口，C接口是其他语言最容易调用的接口。

不过也有一些必须由特定语言来实现的接口，这样就必须依赖某种语言了，比如spin方法，需要语言相关的线程支持。

在ROS1中，并不像ROS2有分层，所有的接口都是一体的，底层直接暴露给应用层。所以你可以设计一个完全的python ros，称作rospy。

这种不分层的架构的好处就是对于python来讲不需要编译了，但是不分层意味着很多重复的代码（c++实现udpros，py实现udpros），bug修复需要执行多次。

![](https://tcs.teambition.net/storage/3126cb30fa72134e62855bf5c2f949a5e5d3?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3MTc5ODk2NCwiaWF0IjoxNjcxMTk0MTY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjZjYjMwZmE3MjEzNGU2Mjg1NWJmNWMyZjk0OWE1ZTVkMyJ9.ZWAKRj-ZKhsk_437h7HE797W7vY0QNWOLY_Ra6PNbWs&download=image.png "")

ros_to_dds允许直接访问dds资源，不过可能导致问题

# 静态类型：直接生成

静态类型，需要自动生成代码，根据`msg`文件自动生成代码。

![](https://tcs.teambition.net/storage/312674d82f7f876c4064c04ec9d524f01962?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3MTc5ODk2NCwiaWF0IjoxNjcxMTk0MTY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjY3NGQ4MmY3Zjg3NmM0MDY0YzA0ZWM5ZDUyNGYwMTk2MiJ9.XO2fc_Suh69rST2eGkStZ6zLQ9csvXgwO5E3UyJxVwA&download=image.png "")

上图右侧

The right hand side of the diagram shows how the `.msg` files are passed directly to language specific code generators, e.g. `rosidl_generator_cpp` or `rosidl_generator_py`. These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the `.msg` files. For example, consider the message `std_msgs/String`, a user might use this file in C++ with the statement `#include <std_msgs/msg/string.hpp>`, or they might use the statement `from std_msgs.msg import String` in Python. These statements work because of the files generated by these language specific (but middleware agnostic) generator packages.

图中可以看到，msg文件直接通过rosidl_generator_cpp等语言相关生成器来生成 的，这些包会生成消息对应的头文件,这些头文件主要用来做内存分配

msg文件是用来type support, type support的含义是：某个类型，对于特定任务的元数据和函数

type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. The type support for a given message might include things like a list of the names and types for each field in the message. It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message.

# 静态类型：间接生成

上图左侧

When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. For example, consider the type specific publish function, when using “vendor A” the function will need to call some of “vendor A“‘s [API](https://docs.ros.org/en/foxy/Glossary.html#term-API), but when using “vendor B” it will need to call “vendor B“‘s [API](https://docs.ros.org/en/foxy/Glossary.html#term-API). To allow for middleware vendor specific code, the user defined `.msg` files may result in the generation of vendor specific code. This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the “Private Implementation” (or Pimpl) pattern works.

For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (`.idl` files), the user defined `rosidl` files (`.msg` files) are converted into equivalent OMG IDL files (`.idl` files). From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. The above diagram shows this on the left hand side, where the `.msg` files are consumed by the `rosidl_dds` package to produce `.idl` files, and then those `.idl` files are given to language specific and DDS vendor specific type support generation packages.

静态转换，在编译器转换

For example, consider the Connext DDS implementation, it has a package called `rosidl_typesupport_connext_cpp`. This package is responsible for generating code to handle do things like publish to a topic for the C++ version of a given message type, using the `.idl` files generated by the `rosidl_dds` package to do so. Again, **this code, while specific to Connext, is still not exposed to the user because of the abstraction in the type support.**

这些代码与特定dds相关，不过不会暴露给用户，因为type support抽象层

msg文件还用来生成特定类型文件，此时这些文件用于与DDS交互，生成一些信息填充到DDS所需要的字段中。

对于符合规范的DDS来讲，需要自动生成idl文件，所以msg文件会转为idl文件

这些包是rosidl_typesupport_dds_c

# 动态类型支持

Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type. Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type. This is referred to as “dynamic” type support, as opposed to “static” type support which requires generated versions of a function for each type.

通用的方法来做type support，静态的方法是将每个类型都生成一个静态type support，动态的含义在于，采用组合元数据的方式，在知道基本数据类型之后，组合基本类型的类型数据即可。

![](https://tcs.teambition.net/storage/3126740584b84ea54831e6ff1a9b57f59de0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3MTc5ODk2NCwiaWF0IjoxNjcxMTk0MTY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjY3NDA1ODRiODRlYTU0ODMxZTZmZjFhOWI1N2Y1OWRlMCJ9.MGUNm3QVBheCjjENkU0D34kSbhhv-3hdXC7OyQ6Rui4&download=image.png "")

上图可看出，msg不需要转换为idl定义，直接转换为用户可用的代码。转化msg的方式还有通用方式，通过这个方式动态将msg转化为dds可以用到的元数据。这就依赖程序的编写，因为是动态的。

`rosidl_typesupport_introspection_c` and `rosidl_typesupport_introspection_cpp`. The `introspection` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. This is the fundamental capability that allows for generic implementations of functions like “publish to a topic”.

`introspection`的含义在于可以查看消息示例的内部元数据的类型。

这些代码是中间件无关的，因为只包含元数据类型。所以这种方法的好处就是可以不同中间件复用。

Also, this approach to type support is normally slower than the static type support alternative. The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type’s meta data to perform things like serialization.

但是缺点在于，需要中间件支持这种动态类型，比如支持xtypes规范，而且相比static而言，动态type support由于在运行时进行类型解析，所以性能较差

# 总结

DDS has two different ways to use and interact with messages.

On the one hand the message can be specified in an IDL file from which usually a DDS implementation specific program will generate source code. The generated code for C++, e.g., contains types specifically generated for the message.

静态支持就是从msg转换到idl，从idl转换到hpp.

On the other hand the message can be specified programmatically using the DynamicData API of the XTypes specification. Neither an IDL file nor a code generation step is necessary for this case.

动态类型支持不需要msg也不需要idl，也不需要生成hpp，所有过程都在运行期执行，可能开销比较大。

Some custom code must still map the message definition available in the ROS .msg files to invocations of the DynamicData API. But it is possible to write generic code which performs the task for any ROS .msg specification passed in.

有些实现，可能需要msg文件来辅助动态生成类型，但是总会有通用代码对任何ROS msg定义都生效。

![](https://tcs.teambition.net/storage/312ge76e0f1c80ff669e3d895fc225f2ef7a?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3MTc5ODk2NCwiaWF0IjoxNjcxMTk0MTY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmdlNzZlMGYxYzgwZmY2NjllM2Q4OTVmYzIyNWYyZWY3YSJ9.60KXndXxKFeD0-DTJAA4BdT7YuqQx7TTLGeOdnojf08&download=image.png "")

# 参考

[https://design.ros2.org/articles/ros_middleware_interface.html](https://design.ros2.org/articles/ros_middleware_interface.html)

[https://design.ros2.org/articles/mapping_dds_types.html](https://design.ros2.org/articles/mapping_dds_types.html)

<http://docs.ros.org/en/rolling/Concepts/About-ROS-2-Client-Libraries.html#id5>

<http://docs.ros.org/en/rolling/Concepts/About-Internal-Interfaces.html>

[About internal ROS 2 interfaces — ROS 2 Documentation: Foxy  documentation](https://docs.ros.org/en/foxy/Concepts/About-Internal-Interfaces.html?highlight=middleware)
