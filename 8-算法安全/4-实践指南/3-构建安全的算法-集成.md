# 构建安全的算法-集成

文章作者Christopher Ho, APEX.OS项目负责人



翻译：黎振胜

翻译者注：**以前我一直觉得系统集成是很low的一件事儿，但看完这篇文章你就不会这么认为了**

## 参考

[https://www.apex.ai/post/building-safe-algorithms-in-the-open-part-3-integration](https://www.apex.ai/post/building-safe-algorithms-in-the-open-part-3-integration)

## 概述

夕阳无限好，只是近黄昏。这个系列的博客也是如此。三部曲快要完结，不过我的文章却不是夕阳。

之前我们深入探索了代码编写技巧，并且产生了最小功能代码——可编译的程序以及一些测试。现在到了最难的一步，让程序在系统中工作。

丑化说在前头——没有银弹！代码集成如果有捷径我早就发财了。相反，我想说的是，下列所有的建议只能让集成过程不至于太痛苦。

然而集成工作总是痛苦的。就我所知道的，一个工程师第一次集成代码时，一定是一个又长又臭的一个过程。

但是当事情真的做成的时候，又是激动人心的。而且更重要的是，第一次集成也是最难受的一次，每一次做都会有不同的收获，后面就好多了。

## 什么是集成

写代码的最后一天，将你写的代码插入一个大系统中，进行调试，观察为什么不能工作，解决问题，这是一个排查故障的过程。

对于解决难的技术问题，我推荐好朋友的一篇文章https://github.com/kmille/linux-debugging/blob/master/mindset.md

概括一下就是：

- 明白算法的流程

- 写测试来判断你遇到问题在算法流程中发生的位置

- 解决问题

- 重复上述步骤



基本上，计算机总的来讲还是串行运行的。但是当你开始接触多线程和底层汇编代码，就会有点模糊了，会有一些奇怪的事情发生。

不过呢，从宏观层面来看，算法基本还是一个顺序执行的模式（如果是并行算法，事情的复杂度又会提升一个量级）

一旦问题是顺序的，我们就一定可以使用一个经典的工具，二分法排故障，这个工具的应用就是在输入和输出上进行数据检查。

（译者注：另一个经典工具是printf，老打桩人了）

打印printf也是一个很简单的测试手段，可以测试模块功能与设计的一致性。

理想情况下，有完整的规约，也有完整的测试用例来保证遵守设计规约。但是实际情况下不是这样，设计规约是模糊的甚至是错误的，API也许没有测试用例甚至是错的，而且开发者总没有时间做这些事儿。

还是强调一下，一定要做测试，但是我更像强调的是如何复现故障。

一旦你能够复现问题，那么就离解决问题不远了。所以出现故障时候，将算法流程弄清楚，然后找到出问题的模块，理解故障的本质。然后问题就迎刃而解。

不过并不总是这么容易，一般来讲，当你发现一个问题，还有一连串的问题，那么你就陷入无穷的解决问题的循环中。

或者到最后，你给你的模块设置了一个约束：该算法必须工作在给定的ODD中。（参考 `https://www.sae.org/news/2019/11/odds-for-av-testing`）

以上就是算法软件集成的总体步骤。本质就是个排故障的过程。集成工作会很痛苦。

所以我们需要做一些准备工作来尽量缓解集成工作的痛苦。



## 让集成工作不那么痛苦的措施

### 集成测试

集成测试就是多个组件共同工作的测试，在这儿一个组件主要指一个ROS节点

在集成测试中，你需要模拟组件在真实系统中的行为。对于ROS中来讲，就是模拟提供合理的输入（比如输入轨迹序列来测试控制器），并且期望获得一些合理的输出。

撰写更加强大的测试来测试算法复杂性和控制流程的完整性，不过这对代码能力要求更大，也能够发现更多问题。

https://github.com/ros2/launch/tree/master/launch_testing

如果你不喜欢，那么也可以自己基于GTest 框架写集成测试工具

而且，我负责了APEX第一个测试，这个测试只有一行命令，执行一个可执行文件，只是看一下有没有崩溃。

### 关于状态

一些读者可能看过我之前博客反复提及的对象的状态问题，即理解和保护好对象的状态有助于设计好的类。我们再次思考一下。

如果对象的内部状态没有维护好，就会出现大大小小的BUG，所以开发者应该：

- 知道由哪些变化的状态

- 确保满足进入状态的条件，状态条件是满足的

- 最小化对象的状态

前两个比较好理解，主要靠编程就能满足（编程规约来保证）

最后一个是KISS原则的应用，Keep it simple and stupid，如果状态更少，那么出错也会更少。

有一个测试方法可以快速定位状态故障，是背对背测试，这也是ISO26262的推荐测试方法。

（译者注：back to back test背对背测试是主机给测试对象进行测试，然后接受测试对象的输出）

背对背测试的例子：`https://gitlab.com/aninnymouse/mpc/-/commit/cafda77f0de9576ef4b312853610c55bf4d2d8af`

### 输入校验

输入输出是必然要校验的

从算法角度讲，如果不控制输入，算法肯定要出错。最终的责任在于算法要确保输入满足算法要求。

总的来讲，在任何计算之前都要做数据检查，在状态切换时候也要做检查。

一个例子就是MPC的输入：轨迹，重点检查的是两点：头信息和采样周期

数据检查的规则完全由算法本身决定。

### 和当前实现对比评审

我之前写过一个设计文档，现在要重新提一下，在这里我们主要关注算法综述和当前实现。

如果你不知事物是如何工作的，那么把能工作的和不能工作的对比一下就明白了。

例子，NDT有性能问题，经过和Autoware.ai的NDT对比，发现有三块不同，所以我的同事就逐个测试，来测试AI版本的NDT在哪个模块增强了性能，最终发现了性能提升的具体模块并将其应用。

例子，MPC控制器有稳定性和抖动问题，同样，与AI的版本进行对比发现，有一个点能够提升性能。

综上，我们提出两个建议：

- 与可以工作的实现进行对比

- 技术评审，开发某算法，测试某算法，应用某算法

### 缩短验证环

水越来越深了，到此为止我已经没有很好的改善型建议给你了。剩下的都是缓解痛苦的建议。

第一个建议（也是常见的软件工程实践）是缩短验证流程

- 一键构建脚本

- 一键开启测试

一键构建可能大部分项目都能做到，一键测试就不一定了。ROS2的launch system很有用，能够执行随机的命令，可以按照顺序执行，这可以使得测试自动化。

### 其他事项

最后，我能给的建议就只剩下提桶跑路了。

## 总结

介绍了NDT和MPC的开发，作为V开发模型的例子。我们从一个概念开始，将概念转化为计划，根据计划进行开发，确保开发完成。最后的成果就是两个能够在最小环境中工作的算法。

接下来还需要做什么？

一般来讲还可以做的事情：

- 偿还技术债，提升可靠性

- 增加功能（可能降低可用性和可靠性）

（技术债定义：`https://en.wikipedia.org/wiki/Technical_debt`）

技术债是客观存在的，而且必须解决。

在NDT的开发中，可以把架构再优化一下，增加更多的集成测试，提升可靠性和鲁棒性。

对于MPC来讲，可以增加更多集成测试，优雅解决corner case极端情况，增强计算器的可靠性和稳定性。

在我看来，技术债如果不解决，一定会反噬你，解决技术债从长远来看可以帮助你开发更快。

与技术债不同，对新功能的需求是一直存在的。但是新功能带来新的技术债，然后问题依旧。

最终，项目往何处走，还是取决于项目经理，以及老板。我不是老板，所以我说的也不算数。

但是如果没别的事情做的话，我还是会选择偿还技术债，因为到后面，做好工作，做出好产品本身就令人满意。

而且我相信，我们在开源世界共享好的算法，做得很不错！